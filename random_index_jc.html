<!DOCTYPE html>
<meta charset ="utf-8">
<html>
  <head>
    <link rel="stylesheet" href="/style.css" type="text/css" />
    <script type="text/javascript" src="/d3.v3.min.js"> </script>
	<script type="text/javascript" src="/math.min.js"> </script>
	<!--<script type="text/javascript" src="/index.js"> </script>-->
  </head>
 <body>
 <h1>This is a heatmap example using d3.js</h1>
 <div id="chart" style="WHITE-SPACE:nowrap"></div>
 <div id="legend"></div>
 <ul id="menu"> 
  <li>excellent,keep the cluster</li> 
  <li>good but can be further improved</li> 
  <li>not good nor bad</li> 
  <li>bad,consider rebuilding the cluster</li>
  <li>terrible,must rebuild it</li>   
</ul>
 <defs>  
    <linearGradient id="myGradient" x1="0%" y1="0%" x2="100%" y2="0%">  
        <stop offset="0%" stop-color="#F00" />  
        <stop offset="100%" stop-color="#0FF" />  
    </linearGradient>  
 </defs> 
 <script type="text/javascript">
        var data = new Array()
		var array_data =[]
		var a= d3.rgb(0,255,0)
		var b= d3.rgb(255,0,0)
		var compute = d3.interpolate(a,b)
		var matrixrow = 200
		var matrixcol = 15
		for(var i=0;i<matrixrow;i++){
		    data[i]= new Array();
			for(var j=0;j<matrixcol;j++){
			    data[i][j] = Math.floor(Math.random()*100)
				//temp = Math.floor(Math.random()*100)
				array_data[i*matrixrow+j] =data[i][j]
			}
		}
		
		var margin = { top: 0, right: 0, bottom: 0, left: 0 },
		  heatmapwidth = 600,
		  heatmapheight = 800,
		  width = heatmapwidth + margin.left + margin.right,        // ????????????Heatmap???
		  height = heatmapheight + margin.top + margin.bottom,
		  
		  gridSize = Math.floor(width / matrixcol),    // ???????????????width??24?
		  gridSize_h = Math.floor(height / matrixrow),    // ???????????????width??24?
		  legendElementWidth = gridSize_h * 2,    // ????????????????}?
		  buckets = 9,        // ??9?????
		  colors = ["#ffffd9","#edf8b1","#c7e9b4","#7fcdbb","#41b6c4","#1d91c0","#225ea8","#253494","#081d58"]; 
		 
		  var linear = d3.scale.linear()
		    .domain([d3.min(array_data),d3.max(array_data)])
			.range([0,1])
		  var colorScale =d3.scale.quantile()
			.domain([d3.min(array_data),buckets-1,d3.max(array_data)])//???[0,n,?????]
			.range(colors)//??
		  //??chart??svg
		  
		  var svg =d3.select("#chart").append("svg")
			 .attr("width",width+margin.left + margin.right)
			 .attr("height",height +margin.top + margin.bottom)
			 .append("g")//?svg?????g???????g??????
			 .attr("transform","translate("+margin.left+","+margin.top+")")
		  
		  var heatMap =svg.selectAll(".score")
		    .data(array_data)
			.enter()//?data?????????".score"
			.append("rect")
			.attr("x",function(d,i){return (i % matrixrow)*gridSize;})
			.attr("y",function(d,i){return parseInt(i / matrixrow)*gridSize_h;})
			.attr("rx",0)
			.attr("ry",0)
			.attr("class","hour bordered")
			.style("text-anchor", "end")
			.attr("width",gridSize)
			.attr("height",gridSize_h)
			.style("fill","#FFFFFF")
			
		 var tooltip = d3.select("body")
		 .append("div")
		 .attr("class","tooltip")
		 .style("opacity",0.0)
		 // duration(1000) ?1000ns????1s???????
		 heatMap.transition().duration(1)
		    //.style("fill",function(d){return colorScale(d);});
			.style("fill",function(d){return compute(linear(d));})
	     /* heatMap
		  .on("mouseover",function(d){
			 tooltip.html(d)
			 .style("left",(d3.event.pageX) +"px")
			 .style("top",(d3.event.pageY)+"px")
			 .style("opacity",1.0)
		  })*/
		  
		 
		  var svg_block =d3.select("#chart").append("svg")
			 .attr("width", 100)
			 .attr("height",height +margin.top + margin.bottom)
			 .append("g")//?svg?????g???????g??????
			 .attr("transform","translate("+(margin.left+20)+","+0+")")
			  
          //get k non-duplicate random numbers
          var origin = new Array;
		  for(var i=0;i<matrixrow;i++){
		      origin[i] = i+1
		  }
		  origin.sort(function(){
			return 0.5 - Math.random() 
		  })
		  var cut = origin.slice(0,buckets)
	      var data_cut = new Array(buckets)
		  cut = cut.sort(function(a,b){
		    return a-b
		  })
	      
		  for(var i=cut.length-1;i>0;i--){
		    cut[i] = cut[i-1]
			data_cut[i] = Math.floor(cut[i] * matrixrow / heatmapheight)//change from pixel_height scale to data_size scale
		  }
          data_cut[0] =0 		  
 		  cut[0] =0
		  /*for(var i=0;i<cut.length;i++){
		     console.log(Math.floor(cut[i]*matrixrow/heatmapheight))
		  }*/
		  var cluster =new Array(data.length)
		  var row =0,inx = 0
		  while(row < data.length){
		     for(row=data_cut[inx];row<data_cut[inx+1];row++){
			     cluster[row] =inx
			 }
			 if(inx+1 < buckets -1){
			     inx++
			 }else{
			     for(row = data_cut[buckets-1];row < data.length;row++){
			         cluster[row] =buckets-1
			     } 
			 }
		  }
		  /*for(var i =0;i < data.length;i++){
		     console.log(cluster[i])
		  }*/
		  var edge_highlight =function(i){
		      svg_block.append("line")
              	.attr("x1",0)
                .attr("y1",cut[i])				
				.attr("x2",block_rec.attr("width"))
				.attr("y2",cut[i])
				.attr("stroke","yellow")
                .attr("stroke-width",5)
				svg.append("line")
              	.attr("x1",0)
                .attr("y1",cut[i])				
				.attr("x2",width)
				.attr("y2",cut[i])
				.attr("stroke","yellow")
                .attr("stroke-width",2)
			    if(i < cut.length-1){
				   svg_block.append("line")
					.attr("x1",0)
					.attr("y1",cut[i+1])				
					.attr("x2",block_rec.attr("width"))
					.attr("y2",cut[i+1])
					.attr("stroke","yellow")
					.attr("stroke-width",5)
				   svg_block.append("line")
					.attr("x1",block_rec.attr("width"))
					.attr("y1",cut[i])				
					.attr("x2",block_rec.attr("width"))
					.attr("y2",cut[i+1])
					.attr("stroke","yellow")
					.attr("stroke-width",5)
				   svg_block.append("line")
					.attr("x1",0)
					.attr("y1",cut[i])				
					.attr("x2",0)
					.attr("y2",cut[i+1])
					.attr("stroke","yellow")
					.attr("stroke-width",5)
				   svg.append("line")
					.attr("x1",0)
					.attr("y1",cut[i+1])				
					.attr("x2",width)
					.attr("y2",cut[i+1])
					.attr("stroke","yellow")
					.attr("stroke-width",2)
				   svg.append("line")
					.attr("x1",0)
					.attr("y1",cut[i])				
					.attr("x2",0)
					.attr("y2",cut[i+1])
					.attr("stroke","yellow")
					.attr("stroke-width",5)
				   svg.append("line")
					.attr("x1",width)
					.attr("y1",cut[i])				
					.attr("x2",width)
					.attr("y2",cut[i+1])
					.attr("stroke","yellow")
					.attr("stroke-width",5)
			    }else{
				   svg_block.append("line")
					.attr("x1",0)
					.attr("y1",height)				
					.attr("x2",block_rec.attr("width"))
					.attr("y2",height)
					.attr("stroke","yellow")
					.attr("stroke-width",5)
				   svg_block.append("line")
					.attr("x1",0)
					.attr("y1",cut[i])				
					.attr("x2",0)
					.attr("y2",height)
					.attr("stroke","yellow")
					.attr("stroke-width",5)
				   svg_block.append("line")
					.attr("x1",block_rec.attr("width"))
					.attr("y1",cut[i])				
					.attr("x2",block_rec.attr("width"))
					.attr("y2",height)
					.attr("stroke","yellow")
					.attr("stroke-width",5)
				   svg.append("line")
					.attr("x1",0)
					.attr("y1",height)				
					.attr("x2",width)
					.attr("y2",height)
					.attr("stroke","yellow")
					.attr("stroke-width",2)
				   svg.append("line")
					.attr("x1",0)
					.attr("y1",cut[i])				
					.attr("x2",0)
					.attr("y2",height)
					.attr("stroke","yellow")
					.attr("stroke-width",5)
				   svg.append("line")
					.attr("x1",width)
					.attr("y1",cut[i])				
					.attr("x2",width)
					.attr("y2",height)
					.attr("stroke","yellow")
					.attr("stroke-width",5) 
		      }
		  }
		  //Sihoutte coefficient
		  var estimate = function(cluster,data){
		     var a =new Array(data.length),
			 b =new Array(data.length),
			 s =new Array(data.length),//sihoute for each row
			 g =new Array(buckets),//sihoute for each group
			 centers = new Array(buckets)//center for  each group
			 for(var i=0;i<buckets;i++){
			     centers[i] = math.zeros(data[0].length)
			 }
			 avg_s =0
		     for(var row=0; row< data.length; row++){
			    a[row]=0
				b[row]=0
				s[row]=0
			    var inside =0,outside=0
				centers[cluster[i]] = math.add(centers[cluster[i]],data[row])
			    for(var other=0;other< data.length;other++){
				    if(row == other){
					    continue;
					}
					var distance =0;
					math.square(math.add(data[row],math.multiply(data[other],-1)))
					.map(function(value,index,matrix){
						distance += value;
					})
					
					if(cluster[row] == cluster[other]){//distance within cluster
   						a[row] += Math.sqrt(distance)
						inside++
					}else{//distance among cluster
					    b[row] += Math.sqrt(distance)
						outside++
					}		
				}
				if(inside > 0){
					a[row] = a[row] /inside
			    }
				if(outside > 0){
					b[row] = b[row] /outside
			    }
				s[row] = (b[row] -a[row])/Math.max(a[row],b[row])
				avg_s += s[row]
			 }
			 for(var i=1;i<buckets;i++){
			    centers[i-1] = math.multiply(centers[i-1],1/(cut[i]-cut[i-1]))
			 }
			 centers[buckets-1] = math.multiply(centers[buckets-1],1/(matrixrow-cut[cut.length-1]))
	
	         var sorted_points =new Array(buckets)
			 for(var i=0;i<g.length;i++){
			    g[i] =0
				sorted_points[i] = new Array
			 }
			 
			 for(var row=0; row< data.length; row++){
			    var distance =0;
			    math.square(math.add(data[row],math.multiply(centers[cluster[row]],-1)))
					.map(function(value,index,matrix){
						distance += value;
					})
			    sorted_points[cluster[row]].push([row,distance])
			    g[cluster[row]] += s[row]
			 }
			 
			 for(var i =0;i<buckets;i++){
			    sorted_points[i] =sorted_points[i].sort(function(x,y){return a[1]-b[1]})
				.map(function(item,index){return item[0]})
				for(var j=0;j< sorted_points[i].length;j++){
					console.log(sorted_points[i][j])
				}
			 }
			 
			 for(var i=1;i <cut.length;i++){
			    g[i-1] /= (cut[i]-cut[i-1])
				if(g[i-1]<0){
				    g[i-1] = -g[i-1]//to make positive,should be removed
				}
			 }
			 g[cut.length-1] /= (matrixrow - cut[cut.length-1])			 
			 if(g[cut.length-1]<0){
			     g[cut.length-1] = -g[cut.length-1]
			 }
			 avg_s /= data.length 
			 console.log(avg_s)
			 return {avg:avg_s,group:g}
		  }
		  
		  var est_obj = estimate(cluster,data)
		  
		  var omenu=d3.select("#menu")
          .style("display","none")
		  .on("mouseout",function(d,i){
		     //omenu.style("display","none")
		  }); 
          var title = document.getElementById("menu").getElementsByTagName("li")
		  for(var index=0;index<title.length;index++){ 
			title[index].onmouseover=function(){ 
			  this.className="active";
			}; 
			title[index].onclick=function(){
			  omenu.style("display","none")
			  //alert("user's comment to cluster "+index+ " is:"+event.srcElement.innerHTML)
			};
			title[index].onmouseout=function(){
			  this.className=""; 
			}; 
		  } 
		  //block on the right
		  var block = svg_block.selectAll(".block")
             // .data([0].concat(colorScale.quantiles()), function(d) { return d; });
             .data(cut)
          block.enter().append("g")
             .attr("class", "block");
          
          var block_rec =block.append("rect")
		    .attr("x", 0)
			//.attr("y", function(d, i) { return height /colors.length * i;})
			.attr("y",function(d,i){
				return d;
			})
            .attr("width", 60)
            //.attr("height", height/colors.length)
			.attr("height",function(d, i){
			     if(i<cut.length-1) return cut[i+1]-cut[i]
				 return height-cut[i]
			})
            .style("fill", function(d, i){return colors[i];})
		  //console.log(block_rec.attr("width"))
		  	   //bind block's listener		
			block_rec.on("mouseover",function(d,i){
			    edge_highlight(i)
			    rects.filter(function(data, inx) { return inx == i; }).attr("fill","yellow");
		    })
			.on("mouseout",function(d,i){
			   rects.filter(function(data,inx){return inx ==i;})
			   .transition()
			   .duration(500)
			   .attr("fill","steelblue");			
			   svg_block.selectAll("line").remove()
			   svg.selectAll("line").remove()
			   //omenu.style("display","none")
			})
			.on("contextmenu", function(data, index) {
			   //handle right click
			   var menu =document.getElementById("menu")
			   menu.removeChild(menu.childNodes[0])
			   menu.insertAdjacentHTML("afterBegin","<h>The sihoute coefficient for this cluster is:"+est_obj.group[index]+",how do you like this cluster?</h>")
			   omenu
			   .style("display","block")
			   .style("left",(d3.event.pageX) +"px")
			   .style("top",(d3.event.pageY)+"px")
			   d3.event.preventDefault()
			});
          block.exit().remove();
		  /*block.append("text")
            .attr("class", "mono")
            .text(function(d,i) { return "label:" + i; })
            .attr("x", 80)
            //.attr("y", function(d, i) { return height /colors.length * i ;})
			.attr("y",function(d,i){
			    return d
			})
            .style("writing-mode","tb-rl")*/
          
			
		 // draw charts of sihoute coefficient for each cluster
		 var svg_chart =d3.select("#chart").append("svg")
			 .attr("width", 500)
			 .attr("height",height +margin.top + margin.bottom)
			 .append("g")//?svg?????g???????g??????
			 .attr("transform","translate("+(margin.left+20)+","+0+")")
		 var padding ={left:50,right:30,top:20,bottom:20}
		 var xScale =d3.scale.ordinal()
                       .domain(d3.range(est_obj.group.length))
                       .rangeRoundBands([0,500-padding.left-padding.right])
         var yScale =d3.scale.linear()
                       .domain([0,d3.max(est_obj.group)])
                       .range([height +margin.top + margin.bottom-padding.top-padding.bottom,0])					   
	     var xAxis =d3.svg.axis()
                      .scale(xScale)
                      .orient("bottom")
         var yAxis =d3.svg.axis()
                      .scale(yScale)
                      .orient("left")
		 var rectPadding =4
		 var rects = svg_chart.selectAll(".MyRect")
		              .data(est_obj.group)
					  .enter()
					  .append("rect")
					  .attr("class","MyRect")
					  .attr("transform","translate("+padding.left+","+padding.top+")")
					  .attr("x",function(d,i){
					      return xScale(i) + rectPadding /2
					  })
					  .attr("y",function(d,i){
					      return yScale(d)
					  })
					  .attr("width", xScale.rangeBand() - rectPadding )
					  .attr("height", function(d){
						  return height - padding.top - padding.bottom - yScale(d);
					  })
					  .attr("fill","steelblue")        //???????????CSS??
					  .on("mouseover",function(d,i){
						  d3.select(this)
							.attr("fill","yellow");
						  edge_highlight(i)
					    })
					 .on("mouseout",function(d,i){
						  d3.select(this)
							.transition()
							.duration(500)
							.attr("fill","steelblue");
						  svg_block.selectAll("line").remove()
			              svg.selectAll("line").remove()
						})
						
         var texts = svg_chart.selectAll(".MyText")
			.data(est_obj.group)
			.enter()
			.append("text")
			.attr("class","MyText")
			.attr("transform","translate(" + padding.left + "," + padding.top + ")")
			.attr("x", function(d,i){
				return xScale(i) + rectPadding/2;
			} )
			.attr("y",function(d){
				return yScale(d);
			})
			.attr("dx",function(){
				return (xScale.rangeBand() - rectPadding)/2;
			})
			.attr("dy",function(d){
				return 20;
			})
			.text(function(d){
				return d;
			});
		 svg_chart.append("g")
		    .attr("class","axis")
			.attr("transform","translate(" + padding.left + "," + (height +margin.top + margin.bottom-padding.bottom) + ")")
            .call(xAxis); 
    	 svg_chart.append("g")
		    .attr("class","axis")
            .attr("transform","translate(" + padding.left + "," + padding.top + ")")
            .call(yAxis);
         

			
			
      //???legend
		 var svg_legend =d3.select("#legend").append("svg")
			 .attr("width", 300)
			 .attr("height",80)
			 .attr("x",50)
			 .attr("y", heatmapheight)
		  var defs =svg_block.append("defs")
		  var linearGradient = defs.append("linearGradient")  
                        .attr("id","linearColor")  
                        .attr("x1","0%")  
                        .attr("y1","0%")  
                        .attr("x2","100%")  
                        .attr("y2","0%");  
  
          var stop1 = linearGradient.append("stop")  
                .attr("offset","0%")  
                .style("stop-color",a.toString());  
  
		  var stop2 = linearGradient.append("stop")  
                .attr("offset","100%")  
                .style("stop-color",b.toString());
		  var colorRect = svg_legend.append("rect")
                .attr("x", 100)  
                .attr("y", 0)  
                .attr("width", 200)  
                .attr("height", 30)  
                .style("fill","url(#" + linearGradient.attr("id") + ")"); 
          var text_small =svg_legend.append("text")
              	.attr("class","small")
                .text("small")
                .attr("x",100)
				.attr("y",60)
		  var text_large =svg_legend.append("text")
              	.attr("class","large")
                .text("large")
                .attr("x",250)
				.attr("y",60)
       
         d3.select("body").on("click",function(d,i){
		      omenu.style("display","none")
		 })
 </script>
 </body>
 </html>